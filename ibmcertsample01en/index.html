<!DOCTYPE html>
<html lang="english">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>IBM Quantum Developer Certification Sample Test Explanation Part 1 | Schrodin&#39;s Diary on Quantum Computing and Quantum Programming</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="In the other page, it was mentioned that, unlike classical computers, quantum computers require quantum programs to be implemented. IBM has been offering a certification related to quantum programming called &lsquo;IBM Certified Associate Developer - Quantum Computation using Qiskit v0.2X&rsquo; since 2021.
https://www.ibm.com/training/certification/ibm-certified-associate-developer-quantum-computation-using-qiskit-v02x-C0010300
By obtaining this certification, you can demonstrate your knowledge of Qiskit and quantum programming.
To earn this certification, you need to pass the exam titled &ldquo;Exam C1000-112: Fundamentals of Quantum Computation Using Qiskit v0.2X Developer,&rdquo; as mentioned in the URL above. IBM also provides a sample Test related to this exam, which is available in the &ldquo;Sample Test&rdquo; section on the website linked above.
However, the explanations are not provided in the Sample Test page, so I will include clear explanations as much as possible. This page contains explanations for questions 1 to 10. For the explanations of questions 11 to 20, please refer to this page.
Please make sure to take full advantage of the following practice exams as extra study material for exam preparation.">
    <meta name="generator" content="Hugo 0.136.4">
    
    
    
    
      <meta name="robots" content="index, follow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.d05fb5f317fcf33b3a52936399bdf6f47dc776516e1692e412ec7d76f4a5faa2.css" >



    
    <script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>



    
      

    

    

    
      <link rel="canonical" href="https://schrodinteq.github.io/ibmcertsample01en/">
    

    <meta property="og:url" content="https://schrodinteq.github.io/ibmcertsample01en/">
  <meta property="og:site_name" content="Schrodin&#39;s Diary on Quantum Computing and Quantum Programming">
  <meta property="og:title" content="IBM Quantum Developer Certification Sample Test Explanation Part 1">
  <meta property="og:description" content="In the other page, it was mentioned that, unlike classical computers, quantum computers require quantum programs to be implemented. IBM has been offering a certification related to quantum programming called ‘IBM Certified Associate Developer - Quantum Computation using Qiskit v0.2X’ since 2021.
https://www.ibm.com/training/certification/ibm-certified-associate-developer-quantum-computation-using-qiskit-v02x-C0010300
By obtaining this certification, you can demonstrate your knowledge of Qiskit and quantum programming.
To earn this certification, you need to pass the exam titled “Exam C1000-112: Fundamentals of Quantum Computation Using Qiskit v0.2X Developer,” as mentioned in the URL above. IBM also provides a sample Test related to this exam, which is available in the “Sample Test” section on the website linked above.
However, the explanations are not provided in the Sample Test page, so I will include clear explanations as much as possible. This page contains explanations for questions 1 to 10. For the explanations of questions 11 to 20, please refer to this page. Please make sure to take full advantage of the following practice exams as extra study material for exam preparation.">
  <meta property="og:locale" content="english">
  <meta property="og:type" content="article">
    <meta property="article:published_time" content="2024-09-27T17:32:53+09:00">
    <meta property="article:modified_time" content="2024-09-27T17:32:53+09:00">

  <meta itemprop="name" content="IBM Quantum Developer Certification Sample Test Explanation Part 1">
  <meta itemprop="description" content="In the other page, it was mentioned that, unlike classical computers, quantum computers require quantum programs to be implemented. IBM has been offering a certification related to quantum programming called ‘IBM Certified Associate Developer - Quantum Computation using Qiskit v0.2X’ since 2021.
https://www.ibm.com/training/certification/ibm-certified-associate-developer-quantum-computation-using-qiskit-v02x-C0010300
By obtaining this certification, you can demonstrate your knowledge of Qiskit and quantum programming.
To earn this certification, you need to pass the exam titled “Exam C1000-112: Fundamentals of Quantum Computation Using Qiskit v0.2X Developer,” as mentioned in the URL above. IBM also provides a sample Test related to this exam, which is available in the “Sample Test” section on the website linked above.
However, the explanations are not provided in the Sample Test page, so I will include clear explanations as much as possible. This page contains explanations for questions 1 to 10. For the explanations of questions 11 to 20, please refer to this page. Please make sure to take full advantage of the following practice exams as extra study material for exam preparation.">
  <meta itemprop="datePublished" content="2024-09-27T17:32:53+09:00">
  <meta itemprop="dateModified" content="2024-09-27T17:32:53+09:00">
  <meta itemprop="wordCount" content="2720">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="IBM Quantum Developer Certification Sample Test Explanation Part 1">
  <meta name="twitter:description" content="In the other page, it was mentioned that, unlike classical computers, quantum computers require quantum programs to be implemented. IBM has been offering a certification related to quantum programming called ‘IBM Certified Associate Developer - Quantum Computation using Qiskit v0.2X’ since 2021.
https://www.ibm.com/training/certification/ibm-certified-associate-developer-quantum-computation-using-qiskit-v02x-C0010300
By obtaining this certification, you can demonstrate your knowledge of Qiskit and quantum programming.
To earn this certification, you need to pass the exam titled “Exam C1000-112: Fundamentals of Quantum Computation Using Qiskit v0.2X Developer,” as mentioned in the URL above. IBM also provides a sample Test related to this exam, which is available in the “Sample Test” section on the website linked above.
However, the explanations are not provided in the Sample Test page, so I will include clear explanations as much as possible. This page contains explanations for questions 1 to 10. For the explanations of questions 11 to 20, please refer to this page. Please make sure to take full advantage of the following practice exams as extra study material for exam preparation.">

      
    
        


  
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Your Page Title</title>
  
  <link rel="icon" type="image/x-icon" href="/ff01.png">
  </head>

  <body class="ma0 avenir bg-near-white production">

    

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Schrodin&#39;s Diary on Quantum Computing and Quantum Programming
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>


    <main class="pb7" role="main">
      
  <div class="flex-l mt2 mw8 center">
    <article class="center cf pv5 ph3 ph4-ns mw7">
      <header>
        <h1 class="f1">
          IBM Quantum Developer Certification Sample Test Explanation Part 1
        </h1>
      </header>
      <div class="nested-copy-line-height lh-copy f4 nested-links mid-gray">
        <p>In the <a href="/c2q01en/">other page</a>, it was mentioned that, unlike classical computers, quantum computers require quantum programs to be implemented. IBM has been offering a certification related to quantum programming called &lsquo;IBM Certified Associate Developer - Quantum Computation using Qiskit v0.2X&rsquo; since 2021.<br>
<a href="https://www.ibm.com/training/certification/ibm-certified-associate-developer-quantum-computation-using-qiskit-v02x-C0010300">https://www.ibm.com/training/certification/ibm-certified-associate-developer-quantum-computation-using-qiskit-v02x-C0010300</a></p>
<p>By obtaining this certification, you can demonstrate your knowledge of Qiskit and quantum programming.</p>
<p>To earn this certification, you need to pass the exam titled &ldquo;Exam C1000-112: Fundamentals of Quantum Computation Using Qiskit v0.2X Developer,&rdquo; as mentioned in the URL above. IBM also provides a sample Test related to this exam, which is available in the &ldquo;Sample Test&rdquo; section on the website linked above.<br>
However, the explanations are not provided in the Sample Test page, so I will include clear explanations as much as possible. This page contains explanations for questions 1 to 10. For the explanations of questions 11 to 20, please refer to <a href="/ibmcertsample02en/">this page</a>.
Please make sure to take full advantage of the following practice exams as extra study material for exam preparation.</p>
<p><a href="https://www.udemy.com/course/ibm-certified-quantum-computation-qiskit-practice-exams/?referralCode=3B3263DF800E05439AD2">https://www.udemy.com/course/ibm-certified-quantum-computation-qiskit-practice-exams/?referralCode=3B3263DF800E05439AD2</a></p>
<p>　</p>
<hr>
<h2 id="sample-test-1">Sample Test 1:</h2>
<p>Which statement will create a quantum circuit with four quantum
bits and four classical bits?</p>
<p><strong>Options:</strong></p>
<ul>
<li><strong>A</strong>. QuantumCircuit(4, 4)</li>
<li><strong>B</strong>. QuantumCircuit(4)</li>
<li><strong>C</strong>. QuantumCircuit(QuantumRegister(4, &lsquo;qr0&rsquo;),
    QuantumRegister(4, &lsquo;cr1&rsquo;))</li>
<li><strong>D</strong>. QuantumCircuit([4, 4])</li>
</ul>
<p><strong>Answer:</strong> A</p>
<p><strong>Explanation:</strong>
In the <a href="/c2q01en/">other page</a>, I have already provided a brief explanation of qubits, but in quantum circuits, classical bits are often defined as measurement bits. In Qiskit, you can define qubits and classical bits as follows. In this example, a circuit with x qubits and y classical bits is defined in the variable qc:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>qc <span style="color:#f92672">=</span> QuantumCircuit(x, y)
</span></span></code></pre></div><p>Therefore, the correct answer is A. For the other options: In B, only 4 qubits are defined, and no classical bits are included. In C, QuantumRegister is used, so classical bits are not defined. D would result in an error if executed.
　　<br>
　　<br>
　　</p>
<hr>
<h2 id="sample-test-2">Sample Test 2:</h2>
<p>Given this code fragment, what is the probability that a
measurement would result in |0&gt; ?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>qc <span style="color:#f92672">=</span> QuantumCircuit(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>ry(<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> math<span style="color:#f92672">.</span>pi<span style="color:#f92672">/</span><span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>)
</span></span></code></pre></div><p><strong>Options:</strong></p>
<ul>
<li><strong>A</strong>. 0.8536</li>
<li><strong>B</strong>. 0.5</li>
<li><strong>C</strong>. 0.1464</li>
<li><strong>D</strong>. 1.0</li>
</ul>
<p><strong>Answer:</strong> C</p>
<p><strong>Explanation:</strong>
In the code from the sample test, one qubit is defined using the <code>QuantumCircuit()</code> function, which was introduced in sample test 1. At this point, the qubit is in the state |0&gt;, meaning that it will always be observed as |0&gt; upon measurement. In this state, the angle $\theta$ representing the tilt from the Z-axis is 0.</p>
<figure><img src="/qstates/0state.png"
    alt="0状態" width="400px">
</figure>

<p>Then, at the point <code>qc.ry(3 * math.pi/4, 0)</code>, the qubit undergoes a rotation around the Y-axis by $\theta = 3\pi/4$. After applying this operation, the qubit will be in the following state:</p>
<figure><img src="/qstates/y34state.png"
    alt="y34状態" width="400px">
</figure>

<p>In this way, on the Bloch sphere, the vector tilts toward the direction of $|0&gt;$ or $|1&gt;$ depending on the value of $\theta$. When the tilt toward the $|0&gt;$ direction is significant (i.e., $\theta &lt; \pi/2$), the probability of measuring $|0&gt;$ increases while the probability of measuring $|1&gt;$ decreases. Conversely, when the tilt toward the $|1&gt;$ direction is significant (i.e., $\pi/2 &lt; \theta$), the probability of measuring $|1&gt;$ increases while the probability of measuring $|0&gt;$ decreases. In this case, as illustrated in the figure, the tilt toward the $|1&gt;$ direction is significant, resulting in a decreased probability of measuring $|0&gt;$. However, since the state does not perfectly align with $|1&gt;$, the probability of measuring $|0&gt;$ is not zero. Therefore, the correct answer is C.</p>
<p>Certainly, you can also represent <code>qc.ry(3*math.pi/4, 0)</code> as a matrix, manually calculate the value of RY|0&gt;, and determine the probability. The representation of RY|0&gt; using matrices and vectors is as follows, which leads to the same conclusion as before.</p>
<p>$$
R_{y(3\pi/4)} |0\rangle =
\begin{bmatrix}
\cos\frac{3\pi}{8} &amp; -\sin\frac{3\pi}{8} \\
\sin\frac{3\pi}{8} &amp; \cos\frac{3\pi}{8}
\end{bmatrix}
\begin{bmatrix}
1 \\
0
\end{bmatrix}
= \cos\frac{3\pi}{8} |0\rangle + \sin\frac{3\pi}{8} |1\rangle
$$</p>
<p>$$
\left|\cos\frac{3\pi}{8}\right|^2 \approx 0.1464
$$
where
$$
R_{y(\theta)} =
\begin{bmatrix}
\cos\frac{\theta}{2} &amp; -\sin\frac{\theta}{2} \\
\sin\frac{\theta}{2} &amp; \cos\frac{\theta}{2}
\end{bmatrix}
$$
　　<br>
　　<br>
　　</p>
<hr>
<h2 id="sample-test-3">Sample Test 3:</h2>
<p>Assuming the fragment below, which three code fragments
would produce the circuit illustrated?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>inp_reg <span style="color:#f92672">=</span> QuantumRegister(<span style="color:#ae81ff">2</span>, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;inp&#39;</span>)
</span></span><span style="display:flex;"><span>ancilla <span style="color:#f92672">=</span> QuantumRegister(<span style="color:#ae81ff">1</span>, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;anc&#39;</span>)
</span></span><span style="display:flex;"><span>qc <span style="color:#f92672">=</span> QuantumCircuit(inp_reg, ancilla)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Insert code here</span>
</span></span></code></pre></div><figure><img src="/qstates/q03.png"
    alt="code03" width="200px">
</figure>

<p><strong>Options:</strong></p>
<ul>
<li><strong>A</strong>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>h(inp_reg)
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>x(ancilla)
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>draw()
</span></span></code></pre></div><p>　　</p>
<ul>
<li><strong>B</strong>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>h(inp_reg[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>x(ancilla[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>draw()
</span></span></code></pre></div><p>　　</p>
<ul>
<li><strong>C</strong>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>h(inp_reg[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>x(ancilla[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>draw()
</span></span></code></pre></div><p>　　</p>
<ul>
<li><strong>D</strong>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>h(inp_reg[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>h(inp_reg[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>x(ancilla[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>draw()
</span></span></code></pre></div><p>　　</p>
<ul>
<li><strong>E</strong>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>h(inp_reg[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>h(inp_reg[<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>x(ancilla[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>draw()
</span></span></code></pre></div><p>　　</p>
<ul>
<li><strong>F</strong>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>h(inp_reg)
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>h(inp_reg)
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>x(ancilla)
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>draw()
</span></span></code></pre></div><p><strong>Answer:</strong> A,B,D</p>
<p><strong>Explanation:</strong>
Let&rsquo;s start by examining the code from the Sample test. In this example, a quantum circuit is created by defining 2 qubits in the variable inp_reg under the name inp, and 1 qubit in ancilla with the name anc. From the diagram, we can observe that an H gate is applied to the 0th and 1st qubits of inp_reg, while an X gate is applied to the 0th qubit of ancilla. The correct solution should replicate this behavior. Let&rsquo;s break it down step by step.<br>
Option A applies an H gate to all of inp_reg and an X gate to all of ancilla, making it correct.<br>
Option B applies an H gate to the 0th and 1st qubits of inp_reg and an X gate to the 0th qubit of ancilla, so it is also correct.<br>
Option C applies an H gate to the 0th qubit of inp_reg and an X gate to the 0th qubit of ancilla, but fails to apply an H gate to the 1st qubit of inp_reg, making it incorrect.<br>
Option D applies an H gate to the 0th and 1st qubits of inp_reg and an X gate to the 0th qubit of ancilla, making it correct.<br>
Option E applies an H gate to the 1st and 2nd qubits of inp_reg and an X gate to the 1st qubit of ancilla, making it incorrect.<br>
Option F applies an H gate twice to all of inp_reg and an X gate to all of ancilla, making it incorrect because there is no need to apply the H gate twice.</p>
<p>　　<br>
　　<br>
　　</p>
<hr>
<h2 id="sampe-test-4">Sampe Test 4:</h2>
<p>Given an empty QuantumCircuit object, qc, with three qubits and
three classical bits, which one of these code fragments would
create this circuit?</p>
<figure><img src="/qstates/33measure.png"
    alt="measure" width="300px">
</figure>

<p><strong>Options:</strong></p>
<ul>
<li><strong>A</strong>. qc.measure([0,1,2], [0,1,2])</li>
<li><strong>B</strong>. qc.measure([0,0], [1,1], [2,2])</li>
<li><strong>C</strong>. qc.measure_all()</li>
<li><strong>D</strong>. qc.measure(0,1,2)</li>
</ul>
<p><strong>Answer:</strong> A</p>
<p><strong>Explanation:</strong>
In the code from the sample test, three qubits are measured using three classical bits. Let&rsquo;s go through it step by step.<br>
Option A correctly measures the 0th, 1st, and 2nd qubits using the 0th, 1st, and 2nd classical bits, making it the correct answer.<br>
Option B has an incorrect format and will result in an error when executed.<br>
Option C uses <code>qc.measure_all()</code>, and while this is close, it does not use the pre-defined classical bits. Instead, it generates a circuit like the one shown below, which makes it incorrect.<br>
<figure><img src="/qstates/measure_all.png"
    alt="measure_all" width="300px">
</figure>

Option D also has an incorrect format and will result in an error when executed.</p>
<p>　　<br>
　　<br>
　　</p>
<hr>
<h2 id="sample-test-5">Sample Test 5:</h2>
<p>Which code fragment will produce a maximally entangled, or
Bell, state?</p>
<p><strong>Options:</strong></p>
<ul>
<li><strong>A</strong>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>bell <span style="color:#f92672">=</span> QuantumCircuit(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>bell<span style="color:#f92672">.</span>h(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>bell<span style="color:#f92672">.</span>x(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>bell<span style="color:#f92672">.</span>cx(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>)
</span></span></code></pre></div><p>　　</p>
<ul>
<li><strong>B</strong>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>bell <span style="color:#f92672">=</span> QuantumCircuit(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>bell<span style="color:#f92672">.</span>cx(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>bell<span style="color:#f92672">.</span>h(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>bell<span style="color:#f92672">.</span>x(<span style="color:#ae81ff">1</span>)
</span></span></code></pre></div><p>　　</p>
<ul>
<li><strong>C</strong>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>bell <span style="color:#f92672">=</span> QuantumCircuit(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>bell<span style="color:#f92672">.</span>h(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>bell<span style="color:#f92672">.</span>x(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>bell<span style="color:#f92672">.</span>cz(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>)
</span></span></code></pre></div><p>　　</p>
<ul>
<li><strong>D</strong>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>bell <span style="color:#f92672">=</span> QuantumCircuit(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>bell<span style="color:#f92672">.</span>h(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>bell<span style="color:#f92672">.</span>h(<span style="color:#ae81ff">0</span>)
</span></span></code></pre></div><p><strong>Answer:</strong> A</p>
<p><strong>Explanation:</strong>
A Bell state refers to a state where measuring the state of one qubit determines the state of the other, as shown below.</p>
<p>$$
\begin{align*}
|\Phi^+\rangle &amp;= \frac{1}{\sqrt{2}} (|00\rangle + |11\rangle), \\
|\Phi^-\rangle &amp;= \frac{1}{\sqrt{2}} (|00\rangle - |11\rangle), \\
|\Psi^+\rangle &amp;= \frac{1}{\sqrt{2}} (|01\rangle + |10\rangle), \\
|\Psi^-\rangle &amp;= \frac{1}{\sqrt{2}} (|01\rangle - |10\rangle).
\end{align*}
$$
For example, in the states $|\Psi^+\rangle$ and $|\Psi^-\rangle$ shown above, if the 0th qubit is measured as 1, it immediately determines that the 1st qubit will be 0.<br>
In this sample test, to create a Bell state, it is necessary to use a CX gate. The CX gate operates on two qubits: a control qubit and a target qubit. If the control qubit is in the state 1, an X gate is applied to the target qubit; if the control qubit is in the state 0, nothing happens.<br>
Therefore, since options C and D do not include a CX gate, we can already determine that they are incorrect.
To create a Bell state, the control qubit must be in a state such as $|+\rangle = \frac{1}{\sqrt{2}} (|0\rangle + |1\rangle)$ or $|-\rangle = \frac{1}{\sqrt{2}} (|0\rangle - |1\rangle)$, where the probability of measuring 0 or 1 is 1/2. The target qubit, on the other hand, must be in a well-defined state of either $|0\rangle$ or $|1\rangle$.<br>
In option A, the 0th qubit is transformed into the $|+\rangle$ state by the H gate, while the 1st qubit is in the definite state of $|1\rangle$. Since the CX gate is applied afterward, this option is correct.<br>
In option B, both the 0th and 1st qubits are in the $|0\rangle$ state, and though the CX gate is applied, this makes the option incorrect.</p>
<p>　　<br>
　　<br>
　　</p>
<hr>
<h2 id="sample-test-6">Sample Test 6:</h2>
<p>Given this code, which two inserted code fragments result in the
state vector represented by this Bloch sphere?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>qc <span style="color:#f92672">=</span> QuantumCircuit(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Insert code fragment here</span>
</span></span><span style="display:flex;"><span>simulator <span style="color:#f92672">=</span> Aer<span style="color:#f92672">.</span>get_backend(<span style="color:#e6db74">&#39;statevector_simulator&#39;</span>)
</span></span><span style="display:flex;"><span>job <span style="color:#f92672">=</span> execute(qc, simulator)
</span></span><span style="display:flex;"><span>result <span style="color:#f92672">=</span> job<span style="color:#f92672">.</span>result()
</span></span><span style="display:flex;"><span>outputstate <span style="color:#f92672">=</span> result<span style="color:#f92672">.</span>get_statevector(qc)
</span></span><span style="display:flex;"><span>plot_bloch_multivector(outputstate)
</span></span></code></pre></div><figure><img src="/qstates/plusstate.png"
    alt="measure" width="300px">
</figure>

<p><strong>Options:</strong></p>
<ul>
<li><strong>A</strong>. qc.h(0)</li>
<li><strong>B</strong>. qc.rx(math.pi / 2, 0)</li>
<li><strong>C</strong>. qc.ry(math.pi / 2, 0)</li>
<li><strong>D</strong>. qc.rx(math.pi / 2, 0)<br>
qc.rz(-math.pi / 2, 0)</li>
<li><strong>E</strong>. qc.ry(math.pi, 0)</li>
</ul>
<p><strong>Answer:</strong> A, C</p>
<p><strong>Explanation:</strong>
Looking at the code, a qubit is defined using <code>QuantumCircuit(1,1)</code>, followed by a section where additional code is added. The qubit, immediately after being defined by <code>QuantumCircuit()</code>, is in the $|0\rangle$ state. The correct code will update this to the state $|+\rangle = \frac{1}{\sqrt{2}} (|0\rangle + |1\rangle)$ as shown in the diagram. Let&rsquo;s go through it step by step.<br>
In A, an H gate is applied, which transforms the $|0\rangle$ qubit into the $|+\rangle$ state as shown in the diagram. Therefore, A is correct.<br>
In B, a rotation of $\pi/2$ around the X-axis is applied, changing the $|0\rangle$ qubit to the following state. As a result, B is incorrect.<br>
<figure><img src="/qstates/mistate.png"
    alt="measure" width="300px">
</figure>

In C, a rotation of $\pi/2$ around the Y-axis is applied, which transforms the qubit into the $|+\rangle$ state as shown in the diagram. Therefore, C is correct.<br>
In D, the operation <code>qc.rx(math.pi / 2, 0)</code> applies a rotation of $\pi/2$ around the X-axis, changing the qubit to the following state.<br>
<figure><img src="/qstates/mistate.png"
    alt="measure" width="300px">
</figure>

Following this, <code>qc.rz(-math.pi / 2, 0)</code> applies a rotation of $-\pi/2$ around the Z-axis, resulting in the final state as shown below. Therefore, D is incorrect.<br>
<figure><img src="/qstates/mstate.png"
    alt="measure" width="300px">
</figure>

In E, a rotation of $\pi$ is applied around the Y-axis, changing the qubit to the state $|1\rangle$ as shown below. Therefore, E is incorrect.<br>
<figure><img src="/qstates/1state.png"
    alt="measure" width="300px">
</figure>
</p>
<p>　　<br>
　　<br>
　　</p>
<hr>
<h2 id="sample-test-7">Sample Test 7:</h2>
<p>S-gate is a Qiskit phase gate with what value of the phase
parameter?</p>
<p><strong>Options:</strong></p>
<ul>
<li>
<p><strong>A</strong>. $\pi/4$</p>
</li>
<li>
<p><strong>B</strong>. $\pi/2$</p>
</li>
<li>
<p><strong>C</strong>. $\pi/8$</p>
</li>
<li>
<p><strong>D</strong>. $\pi$</p>
</li>
</ul>
<p><strong>Answer:</strong> B</p>
<p><strong>Explanation:</strong>
Gates that apply rotations around the Z-axis include the T, S, and Z gates, which rotate the state by phases of $\pi/4$, $\pi/2$, and $\pi$ respectively. Therefore, the correct answer is B.</p>
<p>　　<br>
　　<br>
　　</p>
<hr>
<h2 id="sample-test-8">Sample Test 8:</h2>
<p>Which two code fragments, when inserted into the code below,
will produce the statevector shown in the output?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> qiskit <span style="color:#f92672">import</span> QuantumCircuit, Aer, execute
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> math <span style="color:#f92672">import</span> sqrt
</span></span><span style="display:flex;"><span>qc <span style="color:#f92672">=</span> QuantumCircuit(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Insert fragment here</span>
</span></span><span style="display:flex;"><span>simulator <span style="color:#f92672">=</span> Aer<span style="color:#f92672">.</span>get_backend(<span style="color:#e6db74">&#39;statevector_simulator&#39;</span>)
</span></span><span style="display:flex;"><span>result <span style="color:#f92672">=</span> execute(qc, simulator)<span style="color:#f92672">.</span>result()
</span></span><span style="display:flex;"><span>statevector <span style="color:#f92672">=</span> result<span style="color:#f92672">.</span>get_statevector()
</span></span><span style="display:flex;"><span>print(statevector)
</span></span></code></pre></div><p>　　<br>
<strong>Output:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>[<span style="color:#ae81ff">0.707</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0.</span>j <span style="color:#ae81ff">0.</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0.</span>j <span style="color:#ae81ff">0.</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0.</span>j <span style="color:#ae81ff">0.707</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0.</span>j]
</span></span></code></pre></div><p><strong>Options:</strong></p>
<ul>
<li><strong>A</strong>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>v <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span><span style="color:#f92672">/</span>sqrt(<span style="color:#ae81ff">2</span>), <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span>sqrt(<span style="color:#ae81ff">2</span>)]  
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>initialize(v,[<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>])
</span></span></code></pre></div><p>　　</p>
<ul>
<li><strong>B</strong>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>h(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>cx(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>)
</span></span></code></pre></div><p>　　</p>
<ul>
<li><strong>C</strong>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>v1, v2 <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>initialize(v1,<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>initialize(v2,<span style="color:#ae81ff">1</span>)
</span></span></code></pre></div><p>　　</p>
<ul>
<li><strong>D</strong>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>cx(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>measure_all()
</span></span></code></pre></div><p>　　</p>
<ul>
<li><strong>E</strong>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>h(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>h(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>measure_all()
</span></span></code></pre></div><p>　　</p>
<p><strong>Answer:</strong> A, B</p>
<p><strong>Explanation:</strong>
Since there are 2 qubits, the state vector in the output will have four values, corresponding to the coefficients of $|00\rangle$, $|01\rangle$, $|10\rangle$, and $|11\rangle$, respectively. In this case, the output shows that only $|00\rangle$ and $|11\rangle$ have a coefficient of 0.707+0.j, meaning that the state corresponds to $|\Phi^+\rangle = \frac{1}{\sqrt{2}} (|00\rangle + |11\rangle)$. Now, let&rsquo;s determine which code can transform the initial $|00\rangle$ state into this one. We&rsquo;ll review each option step by step.<br>
In option A, qc.initialize(v, [0,1]) is used to initialize the 0th and 1st qubits, and the vector v = [1/sqrt(2), 0, 0, 1/sqrt(2)] matches the state vector in the output. Therefore, A is the correct answer.<br>
In option B, the 0th qubit is transformed into the state $|+\rangle = \frac{1}{\sqrt{2}} (|0\rangle + |1\rangle)$ by applying the H gate, and then a CX gate is applied with the 0th qubit as the control and the 1st qubit as the target. If the 0th qubit is observed as $|0\rangle$, the CX gate does nothing to the 1st qubit, resulting in the state $|00\rangle$. If the 0th qubit is observed as $|1\rangle$, the CX gate applies an X gate to the 1st qubit, resulting in the state $|11\rangle$. Therefore, the quantum state becomes $\frac{1}{\sqrt{2}} (|00\rangle + |11\rangle)$, making this option also correct.<br>
In option C, the 0th qubit is initialized with qc.initialize(v1, 0), resulting in the qubit being in the state $|0\rangle$, and the 1st qubit is initialized with qc.initialize(v2, 1), resulting in the qubit being in the state $|1\rangle$. The final state is $|10\rangle$, making this incorrect.<br>
In option D, a CX gate is applied to the initial state $|00\rangle$, but since the 0th qubit is observed as 0, the CX gate does nothing, leaving the state as $|00\rangle$. Therefore, this option is also incorrect.<br>
In option E, applying H gates to both the 0th and 1st qubits results in both qubits being in the state $|+\rangle$. Combining both qubits leads to the two-qubit state $\frac{1}{2} (|00\rangle + |01\rangle + |10\rangle + |11\rangle)$. Since this state is different from $|\Phi^+\rangle$, this option is also incorrect.</p>
<p>　　<br>
　　<br>
　　</p>
<hr>
<h2 id="sample-test-9">Sample Test 9:</h2>
<p>Which code fragment will produce a multi-qubit gate other than
a CNOT ?</p>
<p><strong>Options:</strong></p>
<ul>
<li>
<p><strong>A</strong>. qc.cx(0,1)</p>
</li>
<li>
<p><strong>B</strong>. qc.cnot(0,1)</p>
</li>
<li>
<p><strong>C</strong>. qc.mct([0],1)</p>
</li>
<li>
<p><strong>D</strong>. qc.cz(0,1)</p>
</li>
</ul>
<p><strong>Answer:</strong> D</p>
<p><strong>Explanation:</strong>
Let&rsquo;s examine each option one by one.<br>
Option A defines a CX gate, making it incorrect.<br>
Option B uses qc.cnot(0,1), which is equivalent to a CX gate, so it is also incorrect.<br>
Option C utilizes qc.mct([0], 1), which defines a multi-controlled Toffoli gate. This gate can specify multiple bits as control bits and applies an X gate to the target bit when all control bits are in the state $|1\rangle$. However, since only the 0th qubit is specified as the control bit in this case, it effectively results in a gate similar to a CX gate. Therefore, this option is also incorrect.<br>
Option D applies the CZ gate, which applies a Z gate to the target bit when the control bit is $|1\rangle$ and does nothing when the control bit is $|0\rangle$. Since this is a different multi-qubit gate compared to the CX gate, this option is correct.</p>
<p>　　<br>
　　<br>
　　</p>
<hr>
<h2 id="sample-test-10">Sample Test 10:</h2>
<p>Which code fragment will produce a multi-qubit gate other
than a Toffoli?</p>
<p><strong>Options:</strong></p>
<ul>
<li><strong>A</strong>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>ccx(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>)
</span></span></code></pre></div><p>　　</p>
<ul>
<li><strong>B</strong>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>mct([<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">2</span>)
</span></span></code></pre></div><p>　　</p>
<ul>
<li><strong>C</strong>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> qiskit.circuit.library <span style="color:#f92672">import</span> CXGate
</span></span><span style="display:flex;"><span>ccx <span style="color:#f92672">=</span> CXGate()<span style="color:#f92672">.</span>control()
</span></span><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>append(ccx, [<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>])
</span></span></code></pre></div><p>　　</p>
<ul>
<li><strong>D</strong>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>qc<span style="color:#f92672">.</span>cry(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>)
</span></span></code></pre></div><p>　　<br>
　　</p>
<p><strong>Answer:</strong> D</p>
<p><strong>Explanation:</strong>
The multi-controlled Toffoli gate, as mentioned in sample test 9, allows you to specify multiple bits as control bits and applies an X gate to the target bit when all control bits are in the state $|1\rangle$. Let&rsquo;s go through the options one by one.<br>
Option A is called the CCX gate, which also applies an X gate to the target bit when all control bits are in the state $|1\rangle$. Therefore, it is similar to the Toffoli gate and is incorrect. In the expression qc.ccx(0, 1, 2), the 0th and 1st qubits are treated as control bits, while the 2nd qubit serves as the target bit.<br>
Option B is a multi-controlled Toffoli gate, which is incorrect. In the expression qc.mct([0, 1], 2), the 0th and 1st qubits are treated as control bits, while the 2nd qubit serves as the target bit.<br>
Option C imports the CX gate using from qiskit.circuit.library import CXGate and utilizes the .control() method, such as ccx = CXGate().control(), to add additional control bits to create a CCX gate. Therefore, this option is also incorrect.<br>
Option D is known as the controlled rotation Y gate, which applies a rotation about the Y-axis when the control bit is in the state $|1\rangle$. This is a different multi-qubit gate and is therefore correct. In the expression qc.cry(0, 1, 2), the 1st qubit is treated as the control bit, while the 2nd qubit is the target bit, and the rotation angle is 0.</p>
<p>　　</p>
<h2 id="regarding-the-ibm-quantum-developer-certification-exam">Regarding the IBM Quantum Developer Certification Exam</h2>
<p>For those aiming for the quantum developer certification introduced in this blog, I have created practice exams on the Udemy platform! The explanations are crafted to be as clear as possible, so please make sure to take advantage of it!</p>
<h4 id="practice-exams">Practice exams</h4>
<p><a href="https://www.udemy.com/course/ibm-certified-quantum-computation-qiskit-practice-exams/?referralCode=3B3263DF800E05439AD2">https://www.udemy.com/course/ibm-certified-quantum-computation-qiskit-practice-exams/?referralCode=3B3263DF800E05439AD2</a></p>

      </div>
    </article>
  </div>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://schrodinteq.github.io/" >
    &copy;  Schrodin's Diary on Quantum Computing and Quantum Programming 2024 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>

