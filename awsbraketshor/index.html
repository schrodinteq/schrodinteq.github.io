<!DOCTYPE html>
<html lang="english">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Shor&#39;s Algorithm with AWS Amazon Braket | Schrodin&#39;s Diary on Quantum Computing and Quantum Programming</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="In the previous articles, we covered the following topics:
Understanding Quantum Fourier Transform Through Concrete Examples Inverse Quantum Fourier Transform with Qiskit 2.0 Inverse Quantum Fourier Transform with the Amazon Braket SDK Quantum Phase Estimation with Qiskit 2.0 Quantum Phase Estimation with the Amazon Braket SDK Based on this, we will study Shor&rsquo;s algorithm, a quantum algorithm said to be capable of breaking RSA encryption and ECDSA encryption used in Bitcoin transactions.">
    <meta name="generator" content="Hugo 0.128.1">
    
    
    
    
      <meta name="robots" content="index, follow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.13b1b261ee5e4804730aaa2e64ba98f5872177502bbdaf7119319dd9331c082e.css" >



    
    <script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>


<link rel="stylesheet" href="/css/_styles.css">

    
      

    

    

    
      <link rel="canonical" href="https://schrodinteq.github.io/awsbraketshor/">
    

    <meta property="og:url" content="https://schrodinteq.github.io/awsbraketshor/">
  <meta property="og:site_name" content="Schrodin&#39;s Diary on Quantum Computing and Quantum Programming">
  <meta property="og:title" content="Shor&#39;s Algorithm with AWS Amazon Braket">
  <meta property="og:description" content="In the previous articles, we covered the following topics:
Understanding Quantum Fourier Transform Through Concrete Examples Inverse Quantum Fourier Transform with Qiskit 2.0 Inverse Quantum Fourier Transform with the Amazon Braket SDK Quantum Phase Estimation with Qiskit 2.0 Quantum Phase Estimation with the Amazon Braket SDK Based on this, we will study Shor’s algorithm, a quantum algorithm said to be capable of breaking RSA encryption and ECDSA encryption used in Bitcoin transactions.">
  <meta property="og:locale" content="english">
  <meta property="og:type" content="article">
    <meta property="article:published_time" content="2025-07-21T16:43:14+09:00">
    <meta property="article:modified_time" content="2025-07-21T16:43:14+09:00">

  <meta itemprop="name" content="Shor&#39;s Algorithm with AWS Amazon Braket">
  <meta itemprop="description" content="In the previous articles, we covered the following topics:
Understanding Quantum Fourier Transform Through Concrete Examples Inverse Quantum Fourier Transform with Qiskit 2.0 Inverse Quantum Fourier Transform with the Amazon Braket SDK Quantum Phase Estimation with Qiskit 2.0 Quantum Phase Estimation with the Amazon Braket SDK Based on this, we will study Shor’s algorithm, a quantum algorithm said to be capable of breaking RSA encryption and ECDSA encryption used in Bitcoin transactions.">
  <meta itemprop="datePublished" content="2025-07-21T16:43:14+09:00">
  <meta itemprop="dateModified" content="2025-07-21T16:43:14+09:00">
  <meta itemprop="wordCount" content="1407">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Shor&#39;s Algorithm with AWS Amazon Braket">
  <meta name="twitter:description" content="In the previous articles, we covered the following topics:
Understanding Quantum Fourier Transform Through Concrete Examples Inverse Quantum Fourier Transform with Qiskit 2.0 Inverse Quantum Fourier Transform with the Amazon Braket SDK Quantum Phase Estimation with Qiskit 2.0 Quantum Phase Estimation with the Amazon Braket SDK Based on this, we will study Shor’s algorithm, a quantum algorithm said to be capable of breaking RSA encryption and ECDSA encryption used in Bitcoin transactions.">

      
  


    
        


  
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Your Page Title</title>
  
  <link rel="icon" type="image/x-icon" href="/ff01.png">
  </head>

  <body class="ma0 avenir bg-near-white production">

    

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Schrodin&#39;s Diary on Quantum Computing and Quantum Programming
      
    </a>
    <div class="flex-l items-center">
      
<h4></h4>
<ul class="pl0 mr3">
    
    <li class="list f5 f4-ns fw4 dib pr3">
        <a class="hover-white no-underline white-90" href="/japanese/awsbraketshor/">japanese</a>
    </li>
    
</ul>


      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>


    <main class="pb7" role="main">
      
  <div class="flex-l mt2 mw8 center">
    <article class="center cf pv5 ph3 ph4-ns mw7">
      <header>
        <h1 class="f1">
          Shor&#39;s Algorithm with AWS Amazon Braket
        </h1>
      </header>
      <div class="nested-copy-line-height lh-copy f4 nested-links mid-gray">
        <p>In the previous articles, we covered the following topics:</p>
<ul>
<li><a href="/learnqfteasily/">Understanding Quantum Fourier Transform Through Concrete Examples</a></li>
<li><a href="/qiskit20qft/">Inverse Quantum Fourier Transform with Qiskit 2.0</a></li>
<li><a href="/awsbraketqft/">Inverse Quantum Fourier Transform with the Amazon Braket SDK</a></li>
<li><a href="/qiskit20qpe/">Quantum Phase Estimation with Qiskit 2.0</a></li>
<li><a href="/awsbraketqpe/">Quantum Phase Estimation with the Amazon Braket SDK</a></li>
</ul>
<p>Based on this, we will study Shor&rsquo;s algorithm, a quantum algorithm said to be capable of breaking RSA encryption and ECDSA encryption used in Bitcoin transactions.</p>
<hr>
<h4 id="amazon-braket-learning-course">Amazon Braket Learning Course</h4>
<p>You can efficiently learn the basic knowledge of quantum computing—including quantum gates and quantum circuits introduced in this article—as well as how to use Amazon Braket through this course.</p>
<div style="display: flex; align-items: center;">
  <a href="https://www.udemy.com/course/quantum-computing-on-aws-for-beginners-amazon-braket/?referralCode=F361C3FD774489A1B5B8" target="_blank" style="margin-right: 20px;">
    <img src="/mycourses/AWSCourse.webp" alt="QiskitCourseJa" width="170" style="vertical-align: middle;">
  </a>
  <div style="word-break: break-all; font-size: 90%;">
    <a href="https://www.udemy.com/course/quantum-computing-on-aws-for-beginners-amazon-braket/?referralCode=F361C3FD774489A1B5B8" target="_blank">
      Quantum Computing on AWS for Beginners: Amazon Braket
    </a>
  </div>
</div>
<p>This course is designed for those with no prior knowledge of quantum computing or AWS, and by the end, you&rsquo;ll even be able to learn about quantum machine learning.
Take advantage of this opportunity to build your skills in quantum technologies!</p>
<hr>
<h1 id="shors-algorithm">Shor&rsquo;s algorithm</h1>
<p>If quantum computers become capable of handling a sufficient number of qubits, it is said that Shor&rsquo;s algorithm could pose a threat to RSA and ECDSA encryption.
For example, RSA encryption is based on the difficulty of factoring large integers. In this section, we will look at how Shor&rsquo;s algorithm can be used to factor such integers.
The process of factoring an integer $N$ using this algorithm is as follows:</p>
<p><br><br>
<em><strong>Choose an $a$ such that $1 &lt; a &lt; N$ and the greatest common divisor of $a$ and $N$ is $1$.</strong></em>
<br>
　　　　　<em><strong>$\downarrow$</strong></em>
<br>
<em><strong>Determine the period $r$ of the function $a^x \bmod\ N$.</strong></em>
<br>
　　　　　<em><strong>$\downarrow$</strong></em>
<br>
<em><strong>Find a factor of $N$ by computing the greatest common divisor of $a^{\frac{r}{2}} \pm 1$ and $N$.</strong></em>
<br><br></p>
<p>Here, it mentions &lsquo;Determine the period $r$ of the function $a^x \bmod\ N$,&rsquo; so let&rsquo;s look at a concrete example.</p>
<p>As an example, let&rsquo;s consider factoring $N = 39$ by choosing $a = 5$. The graph of $a^x \bmod\ N = 5^x \bmod\ 39$, with $x$ on the horizontal axis, is shown below.</p>
<figure><img src="/Shor/axmodN.webp"
    alt="axmodN" width="800px">
</figure>

<p>Listing the values on the y-axis, we can see that this is a periodic function that returns to its original value after four changes.</p>
<p>$$
1 \rightarrow 5 \rightarrow 25 \rightarrow 8 \rightarrow 1 \rightarrow 5 \rightarrow 25 \rightarrow 8
\tag{1}
$$</p>
<p>This period corresponds to the order $r$, and since the function returns to its original value after 4 steps in this case, we find that $r = 4$.
Shor&rsquo;s algorithm leverages a quantum computer to efficiently compute this $r$, enabling fast factorization.</p>
<p>When it comes to implementing Shor&rsquo;s algorithm, there are two main approaches. One is a general-purpose but complex method that directly defines and uses the function $a^x \bmod\ N$ within a quantum circuit, as described in this <a href="https://arxiv.org/pdf/2311.08555">paper</a>. The other is a simpler implementation that defines and uses an operator based on the observed behavior of $a^x \bmod\ N$ for specific pairs of $a$ and $N$.</p>
<p>In this explanation, we will focus on the simpler implementation method tailored to a specific pair of $a$ and $N$.</p>
<p>To begin, let&rsquo;s go through the initial setup.
The operator that produces the periodic behavior of the function $a^x \bmod\ N$ can be expressed as follows.</p>
<p>$$
U |y\rangle = |a y\bmod\ N\rangle
\tag{2}
$$</p>
<p>Let&rsquo;s look at an example to better understand this. We&rsquo;ll consider the case we&rsquo;ve already seen, where $N = 39$ and $a = 5$. In this case, the expression is as follows.</p>
<p>$$
U |y\rangle = |5 y\bmod\ 39\rangle
$$</p>
<p>When substituting $y = 1$, we obtain the following result.</p>
<p>$$
U |1\rangle = |5 \cdot 1\bmod\ 39\rangle = |5\rangle
$$</p>
<p>Substituting this result back into $y$, we obtain the following.</p>
<p>$$
U |5\rangle = |5 \cdot 5\bmod\ 39\rangle = |25\rangle
$$</p>
<p>Let&rsquo;s substitute this result once again.</p>
<p>$$
U |25\rangle = |5 \cdot 25\bmod\ 39\rangle = |8\rangle
$$</p>
<p>We substitute it again.</p>
<p>$$
U |8\rangle = |5 \cdot 8\bmod\ 39\rangle = |1\rangle
$$</p>
<p>The result has returned to $1$!
Indeed, this operator successfully reproduces the transformation described in (1), and it gives us hope that we might be able to determine the order $r$ using this operator.
(Of course, we may already know the value of $r$ at this point, but since the goal is to derive the answer from the quantum circuit, we’ll pretend we don’t.)</p>
<p>Here, it is known that the eigenvalues of $U$ satisfying condition (2), with eigenstates denoted as $|u_s\rangle$, are given as follows.</p>
<p>$$
U|u_s\rangle =\ e^{\frac{2\pi i s}{r}}|u_s\rangle
$$</p>
<p>This is a form that allows us to derive the solution using <a href="/awsbraketqpe/">the Quantum Phase Estimation algorithm</a>!
Furthermore, the eigenstates of this operator can be expressed as follows.</p>
<p>$$
|u_s\rangle =
\frac{1}{\sqrt{r}}
\sum_{k=0}^{r-1}
e^{-\frac{2\pi i s k}{r}}<br>
\bigl|a^{k}\bmod N\bigr\rangle
\quad (s = 0,1,\dots,r-1)
$$</p>
<p>These eigenstates have a special property: when summed over all $s$, the result is $|1\rangle$.</p>
<p>$$
|1\rangle = \frac{1}{\sqrt{r}} ( |u_0\rangle + |u_1\rangle +&hellip;.. |u_{r-1}\rangle )
$$</p>
<p>In <a href="/awsbraketqpe/">the Quantum Phase Estimation algorithm</a>, we can determine the eigenvalue corresponding to a given eigenstate by defining that eigenstate using qubits.
Based on this property, by setting the eigenstate-defining qubit to $|1\rangle$ and executing quantum phase estimation, we obtain a superposition of eigenvalues $|\psi\rangle$ as shown below.
Here, $n$ denotes the number of qubits in the readout register.</p>
<p>$$
|\psi\rangle = \frac{1}{\sqrt{r}} ( |2^n\cdot\frac{0}{r}\rangle + |2^n\cdot\frac{1}{r}\rangle +&hellip; + |2^n\cdot\frac{r - 1}{r}\rangle )
$$</p>
<p>Since the information about $r$ is embedded in this state, by measuring $|\psi\rangle$, we can estimate the value of $r$ from the result.
The overall procedure of this method can be summarized as follows:
<br><br>
<em><strong>Define the operator $U$ such that, for the given $a$ and $N$, it transforms the state as $U |y\rangle = |a y \bmod\ N\rangle$.</strong></em>
<br>
　　　　　<em><strong>$\downarrow$</strong></em>
<br>
<em><strong>Perform quantum phase estimation on the operator $U$ using the superposition of eigenstates $|1\rangle$.</strong></em>
<br>
　　　　　<em><strong>$\downarrow$</strong></em>
<br>
<em><strong>Estimate $r$ from the measurement result.</strong></em>
<br><br></p>
<p>Let&rsquo;s try it out!</p>
<h2 id="shors-algorithm-with-amazon-braket-sdk">Shor&rsquo;s algorithm with Amazon Braket SDK</h2>
<p>Let’s take this opportunity to try factoring a larger number, $N = 341$.
We’ll set $a = 32$ for this implementation.
First, we define the operator $U$ such that $U |y\rangle = |a y \bmod\ N\rangle$ for $a = 32$ and $N = 341$.
By substituting $y = 1$, we obtain the following result.
$$
U |1\rangle = |32 \cdot 1\bmod\ 341\rangle = |32\rangle
$$
Let&rsquo;s substitute this result once again.
$$
U |32\rangle = |32 \cdot 32\bmod\ 341\rangle = |1\rangle
$$
The state has returned to $|1\rangle$! Therefore, the transformation can be described as follows.</p>
<p>$$
|1\rangle \rightarrow |32\rangle \rightarrow |1\rangle \rightarrow |32\rangle \rightarrow |1\rangle
\tag{3}
$$
This transformation by $U$ can be implemented by applying an X gate to the 6th qubit of the eigenstate register.
Now, let&rsquo;s perform the Quantum Phase Estimation algorithm using this $U$ and the state $|1\rangle$.
To begin, we will follow the code introduced in <a href="/awsbraketqpe/">this article</a>, starting with applying Hadamard gates to the readout register.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> braket.circuits <span style="color:#f92672">import</span> Circuit
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> braket.devices <span style="color:#f92672">import</span> LocalSimulator
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> braket.experimental.algorithms.quantum_fourier_transform <span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    quantum_fourier_transform <span style="color:#66d9ef">as</span> qft_module
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>n_readout_qubits <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>circ <span style="color:#f92672">=</span> Circuit()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> qubit <span style="color:#f92672">in</span> list(range(n_readout_qubits)):
</span></span><span style="display:flex;"><span>    circ<span style="color:#f92672">.</span>h(qubit)
</span></span></code></pre></div><p>We will now define $|1\rangle$ as follows.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>circ<span style="color:#f92672">.</span>x(n_readout_qubits)
</span></span></code></pre></div><p>Then, we apply the controlled-$U$ gate that induces the change in (3), following the rules of the quantum phase estimation algorithm.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>n_eigenstate_qubits <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> ctl_bit <span style="color:#f92672">in</span> list(range(n_readout_qubits)):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> list(range(<span style="color:#ae81ff">2</span><span style="color:#f92672">**</span>(ctl_bit))):
</span></span><span style="display:flex;"><span>        circ<span style="color:#f92672">.</span>cnot(ctl_bit, n_readout_qubits <span style="color:#f92672">+</span> n_eigenstate_qubits <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span></code></pre></div><p>Finally, We apply inverse Quantum Fourier Transformation.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>circ<span style="color:#f92672">.</span>swap(<span style="color:#ae81ff">0</span>,n_readout_qubits <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>circ<span style="color:#f92672">.</span>iqft(range(n_readout_qubits))
</span></span><span style="display:flex;"><span>circ<span style="color:#f92672">.</span>measure([<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>device <span style="color:#f92672">=</span> LocalSimulator()
</span></span><span style="display:flex;"><span>result <span style="color:#f92672">=</span> device<span style="color:#f92672">.</span>run(circ, shots<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span>)<span style="color:#f92672">.</span>result()
</span></span><span style="display:flex;"><span>counts <span style="color:#f92672">=</span> result<span style="color:#f92672">.</span>measurement_counts
</span></span><span style="display:flex;"><span>print(counts)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Output</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Counter({&#39;000&#39;: 501, &#39;100&#39;: 499})</span>
</span></span></code></pre></div><p>For code that estimates $r$ from such results, please refer to this <a href="https://github.com/amazon-braket/amazon-braket-algorithm-library/blob/main/src/braket/experimental/algorithms/shors/shors.py"><code>get_factors_from_results() function</code></a>.
In this case, we can estimate $r = 2$ from the results.
Using this value of $r$, we obtain $a^{\frac{r}{2}} + 1 = 33$ and $a^{\frac{r}{2}} - 1 = 31$.
The greatest common divisors of these two numbers with 341 are as follows.</p>
<p>$$
\begin{align}
gcd(33, 341) = 11 \\
gcd(31, 341) = 31
\end{align}
$$
We have successfully found the prime factors of 341: 11 and 31!</p>
<hr>
<h4 id="amazon-braket-learning-course-1">Amazon Braket Learning Course</h4>
<p>You can efficiently learn the basic knowledge of quantum computing—including quantum gates and quantum circuits introduced in this article—as well as how to use Amazon Braket through this course.</p>
<div style="display: flex; align-items: center;">
  <a href="https://www.udemy.com/course/quantum-computing-on-aws-for-beginners-amazon-braket/?referralCode=F361C3FD774489A1B5B8" target="_blank" style="margin-right: 20px;">
    <img src="/mycourses/AWSCourse.webp" alt="QiskitCourseJa" width="170" style="vertical-align: middle;">
  </a>
  <div style="word-break: break-all; font-size: 90%;">
    <a href="https://www.udemy.com/course/quantum-computing-on-aws-for-beginners-amazon-braket/?referralCode=F361C3FD774489A1B5B8" target="_blank">
      Quantum Computing on AWS for Beginners: Amazon Braket
    </a>
  </div>
</div>
<p>This course is designed for those with no prior knowledge of quantum computing or AWS, and by the end, you&rsquo;ll even be able to learn about quantum machine learning.
Take advantage of this opportunity to build your skills in quantum technologies!</p>
<hr>

      </div>
    </article>
  </div>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://schrodinteq.github.io/" >
    &copy;  Schrodin's Diary on Quantum Computing and Quantum Programming 2025 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>

